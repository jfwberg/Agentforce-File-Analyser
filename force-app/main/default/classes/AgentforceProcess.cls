/**
 * @description Class representing the output generated by the AgentforceProcessValidator
 */
public class AgentforceProcess {

    public class Process {

        public String processId;
        public String processName;
        public String processDescription;
        public String processVersion;
        public String processSummary;
        public String startStepId;
        public List<String> actorRoles;
        public List<String> tags;
        public Step[] processSteps;
        public String[] notes;

        
        public List<String> validate() {
            
            List<String> errs = new List<String>();

            // Required roots
            if(String.isBlank(processId)){        
                errs.add('processId is required.');
            }
            
            if(String.isBlank(processName)){      
                errs.add('processName is required.');
            }
           
            if(String.isBlank(startStepId)){      
                errs.add('startStepId is required.');
            }
            
            if (processSteps == null || processSteps.isEmpty()){
                errs.add('processSteps must contain at least one step.');
            }

            // Step map & uniqueness
            Map<String, Step> byId = new Map<String, Step>();
            Set<String> ids = new Set<String>();
            if (processSteps != null) {
                for (Integer i = 0; i < processSteps.size(); i++) {
                    Step s = processSteps[i];
                    String ctx = '(step index ' + i + ') ';

                    // Basic presence
                    if(String.isBlank(s.stepId)) {
                        errs.add(ctx + 'stepId is required.');
                        continue;
                    }
                    if (ids.contains(s.stepId)) {
                        errs.add('Duplicate stepId "' + s.stepId + '".');
                    }
                    ids.add(s.stepId);
                    byId.put(s.stepId, s);

                    // stepId format: PS_ + zero-padded digits (>= 3)
                    if (!matches(s.stepId, '^PS_\\d{3,}$')) {
                        errs.add('stepId "' + s.stepId + '" must match ^PS_\\d{3,}$.');
                    }

                    // Action & type
                    if(String.isBlank(s.action)) {
                        errs.add('stepId "' + s.stepId + '": action is required.');
                    }
                    if(String.isBlank(s.type)) {
                        errs.add('stepId "' + s.stepId + '": type is required.');
                    } else if (!ALLOWED_STEP_TYPES.contains(s.type)) {
                        errs.add('stepId "' + s.stepId + '": type must be one of ' + ALLOWED_STEP_TYPES + '.');
                    }

                    // Type-specific rules
                    if (equalsIgnoreCase(s.type, 'Process')) {
                        if(String.isBlank(s.nextStepId)) {
                            errs.add('stepId "' + s.stepId + '": nextStepId is required for type=Process.');
                        }
                        if (s.outcomes != null && !s.outcomes.isEmpty()) {
                            errs.add('stepId "' + s.stepId + '": outcomes not allowed for type=Process.');
                        }
                        if(String.isNotBlank(s.endState)) {
                            errs.add('stepId "' + s.stepId + '": endState not allowed for type=Process.');
                        }
                    } else if (equalsIgnoreCase(s.type, 'Decision')) {
                        if (s.outcomes == null || s.outcomes.isEmpty()) {
                            errs.add('stepId "' + s.stepId + '": outcomes are required for type=Decision.');
                        } else {
                            for (Integer oi = 0; oi < s.outcomes.size(); oi++) {
                                Outcome o = s.outcomes[oi];
                                String octx = ' (outcome index ' + oi + ')';
                                if(String.isBlank(o.condition)) {
                                    errs.add('stepId "' + s.stepId + '"' + octx + ': condition is required.');
                                }
                                if(String.isBlank(o.nextStepId)) {
                                    errs.add('stepId "' + s.stepId + '"' + octx + ': nextStepId is required.');
                                }
                            }
                        }
                        if(String.isNotBlank(s.nextStepId)) {
                            errs.add('stepId "' + s.stepId + '": nextStepId not allowed on type=Decision.');
                        }
                        if(String.isNotBlank(s.endState)) {
                            errs.add('stepId "' + s.stepId + '": endState not allowed on type=Decision.');
                        }
                    } else if (equalsIgnoreCase(s.type, 'End')) {
                        if(String.isNotBlank(s.nextStepId)) {
                            errs.add('stepId "' + s.stepId + '": nextStepId not allowed for type=End.');
                        }
                        if (s.outcomes != null && !s.outcomes.isEmpty()) {
                            errs.add('stepId "' + s.stepId + '": outcomes not allowed for type=End.');
                        }
                        if(String.isNotBlank(s.endState) && !ALLOWED_END_STATES.contains(s.endState.toLowerCase())) {
                            errs.add('stepId "' + s.stepId + '": endState must be one of ' + ALLOWED_END_STATES + '.');
                        }
                    }
                }
            }

            // startStepId exists
            if(String.isNotBlank(startStepId) && !byId.containsKey(startStepId)) {
                errs.add('startStepId "' + startStepId + '" does not match any stepId.');
            }

            // Reference checks (nextStepId / outcomes.nextStepId must exist)
            if (processSteps != null) {
                for (Step s : processSteps) {
                    if (equalsIgnoreCase(s.type, 'Process') && String.isNotBlank(s.nextStepId) && !byId.containsKey(s.nextStepId)) {
                        errs.add('stepId "' + s.stepId + '": nextStepId "' + s.nextStepId + '" does not exist.');
                    }
                    if (equalsIgnoreCase(s.type, 'Decision') && s.outcomes != null) {
                        for (Outcome o : s.outcomes) {
                            if(String.isNotBlank(o.nextStepId) && !byId.containsKey(o.nextStepId)) {
                                errs.add('stepId "' + s.stepId + '": outcome nextStepId "' + o.nextStepId + '" does not exist.');
                            }
                        }
                    }
                }
            }

            return errs;
        }
    }

    public class Step {
        public String stepId;
        public String actor;
        public String actorRole;
        public String action;
        public String type;     
        public String nextStepId;
        public Outcome[] outcomes;
        public String endState;
    }


    public class Outcome {
        public String condition;
        public String nextStepId;
    }

    
    public static List<Process> parse(String jsonString) {
        if(String.isBlank(jsonString)){
            return new List<Process>();
        } 
        return (List<Process>) JSON.deserialize(jsonString, List<Process>.class);
    }

    
    public static List<String> validateJson(String jsonString) {
        
        List<String> errs = new List<String>();
        List<Process> docs = parse(jsonString);
        
        if (docs.isEmpty()) {
            errs.add('Top-level JSON must be a non-empty array of process documents.');
            return errs;
        }
        
        for (Integer i = 0; i < docs.size(); i++) {
            Process d = docs[i];
            
            List<String> per = d.validate();
            
            for (String e : per){
                errs.add('Process index ' + i + ' (' + nvl(d.processId, 'no-id') + '): ' + e);
            }
        }
        return errs;
    }

   

    private static final Set<String> ALLOWED_STEP_TYPES = new Set<String>{ 'Process', 'Decision', 'End' };
    private static final Set<String> ALLOWED_END_STATES = new Set<String>{ 'success', 'failure', 'cancelled' };

    
    private static Boolean equalsIgnoreCase(String a, String b) {
        if (a == null || b == null){
            return a == b;
        }

        return a.equalsIgnoreCase(b);
    }
    
    private static Boolean matches(String input, String regex) {
        if (String.isBlank(input)){
            return false;
        }

        return Pattern.matches(regex, input);
    }

    private static String nvl(String s, String d) { return String.isBlank(s) ? d : s; }
}